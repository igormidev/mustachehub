// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'analysed_segment_status.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AnalysedSegmentStatus {
  TextOffset get offset => throw _privateConstructorUsedError;
  String get segmentText => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AnalysedSegmentStatusCopyWith<AnalysedSegmentStatus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalysedSegmentStatusCopyWith<$Res> {
  factory $AnalysedSegmentStatusCopyWith(AnalysedSegmentStatus value,
          $Res Function(AnalysedSegmentStatus) then) =
      _$AnalysedSegmentStatusCopyWithImpl<$Res, AnalysedSegmentStatus>;
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class _$AnalysedSegmentStatusCopyWithImpl<$Res,
        $Val extends AnalysedSegmentStatus>
    implements $AnalysedSegmentStatusCopyWith<$Res> {
  _$AnalysedSegmentStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_value.copyWith(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnalysedSegmentTextImplCopyWith<$Res>
    implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentTextImplCopyWith(_$AnalysedSegmentTextImpl value,
          $Res Function(_$AnalysedSegmentTextImpl) then) =
      __$$AnalysedSegmentTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentTextImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res, _$AnalysedSegmentTextImpl>
    implements _$$AnalysedSegmentTextImplCopyWith<$Res> {
  __$$AnalysedSegmentTextImplCopyWithImpl(_$AnalysedSegmentTextImpl _value,
      $Res Function(_$AnalysedSegmentTextImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentTextImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentTextImpl implements _AnalysedSegmentText {
  _$AnalysedSegmentTextImpl({required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.normalText(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentTextImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentTextImplCopyWith<_$AnalysedSegmentTextImpl> get copyWith =>
      __$$AnalysedSegmentTextImplCopyWithImpl<_$AnalysedSegmentTextImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return normalText(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return normalText?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (normalText != null) {
      return normalText(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return normalText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return normalText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (normalText != null) {
      return normalText(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentText implements AnalysedSegmentStatus {
  factory _AnalysedSegmentText(
      {required final TextOffset offset,
      required final String segmentText}) = _$AnalysedSegmentTextImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentTextImplCopyWith<_$AnalysedSegmentTextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentValidImplCopyWith<$Res>
    implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentValidImplCopyWith(_$AnalysedSegmentValidImpl value,
          $Res Function(_$AnalysedSegmentValidImpl) then) =
      __$$AnalysedSegmentValidImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentValidImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentValidImpl>
    implements _$$AnalysedSegmentValidImplCopyWith<$Res> {
  __$$AnalysedSegmentValidImplCopyWithImpl(_$AnalysedSegmentValidImpl _value,
      $Res Function(_$AnalysedSegmentValidImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentValidImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentValidImpl implements _AnalysedSegmentValid {
  _$AnalysedSegmentValidImpl({required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.validDeclaration(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentValidImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentValidImplCopyWith<_$AnalysedSegmentValidImpl>
      get copyWith =>
          __$$AnalysedSegmentValidImplCopyWithImpl<_$AnalysedSegmentValidImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (validDeclaration != null) {
      return validDeclaration(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (validDeclaration != null) {
      return validDeclaration(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentValid implements AnalysedSegmentStatus {
  factory _AnalysedSegmentValid(
      {required final TextOffset offset,
      required final String segmentText}) = _$AnalysedSegmentValidImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentValidImplCopyWith<_$AnalysedSegmentValidImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<$Res>
    implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith(
          _$AnalysedSegmentInvalidMapDeclarationImpl value,
          $Res Function(_$AnalysedSegmentInvalidMapDeclarationImpl) then) =
      __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentInvalidMapDeclarationImpl>
    implements _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<$Res> {
  __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl(
      _$AnalysedSegmentInvalidMapDeclarationImpl _value,
      $Res Function(_$AnalysedSegmentInvalidMapDeclarationImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentInvalidMapDeclarationImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentInvalidMapDeclarationImpl
    implements _AnalysedSegmentInvalidMapDeclaration {
  _$AnalysedSegmentInvalidMapDeclarationImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.invalidMapDeclaration(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentInvalidMapDeclarationImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<
          _$AnalysedSegmentInvalidMapDeclarationImpl>
      get copyWith => __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<
          _$AnalysedSegmentInvalidMapDeclarationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (invalidMapDeclaration != null) {
      return invalidMapDeclaration(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (invalidMapDeclaration != null) {
      return invalidMapDeclaration(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentInvalidMapDeclaration
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentInvalidMapDeclaration(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentInvalidMapDeclarationImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<
          _$AnalysedSegmentInvalidMapDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith(
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl value,
          $Res Function(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl)
              then) =
      __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
    implements
        _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<$Res> {
  __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl(
      _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl _value,
      $Res Function(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl
    implements _AnalysedSegmentModelDeclarationOpenWithoutClose {
  _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.modelDeclarationOpenWithoutClose(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
      get copyWith =>
          __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<
                  _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationOpenWithoutClose != null) {
      return modelDeclarationOpenWithoutClose(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationOpenWithoutClose != null) {
      return modelDeclarationOpenWithoutClose(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentModelDeclarationOpenWithoutClose
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentModelDeclarationOpenWithoutClose(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith(
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl value,
          $Res Function(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl)
              then) =
      __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
    implements
        _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<$Res> {
  __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl(
      _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl _value,
      $Res Function(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl
    implements _AnalysedSegmentModelDeclarationCloseWithoutOpen {
  _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.modelDeclarationCloseWithoutOpen(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
      get copyWith =>
          __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<
                  _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationCloseWithoutOpen != null) {
      return modelDeclarationCloseWithoutOpen(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationCloseWithoutOpen != null) {
      return modelDeclarationCloseWithoutOpen(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentModelDeclarationCloseWithoutOpen
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentModelDeclarationCloseWithoutOpen(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith(
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl value,
          $Res Function(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl)
              then) =
      __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
    implements
        _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<$Res> {
  __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl(
      _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl _value,
      $Res Function(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl
    implements _AnalysedSegmentBooleanDeclarationOpenWithoutClose {
  _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.booleanDeclarationOpenWithoutClose(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
      get copyWith =>
          __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
                  _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationOpenWithoutClose != null) {
      return booleanDeclarationOpenWithoutClose(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationOpenWithoutClose != null) {
      return booleanDeclarationOpenWithoutClose(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentBooleanDeclarationOpenWithoutClose
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentBooleanDeclarationOpenWithoutClose(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWith(
          _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl value,
          $Res Function(_$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl)
              then) =
      __$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl>
    implements
        _$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWith<$Res> {
  __$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWithImpl(
      _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl _value,
      $Res Function(_$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl
    implements _AnalysedSegmentChoiceDeclarationOpenWithoutClose {
  _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.choiceDeclarationOpenWithoutClose(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl>
      get copyWith =>
          __$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWithImpl<
                  _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return choiceDeclarationOpenWithoutClose(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return choiceDeclarationOpenWithoutClose?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (choiceDeclarationOpenWithoutClose != null) {
      return choiceDeclarationOpenWithoutClose(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return choiceDeclarationOpenWithoutClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return choiceDeclarationOpenWithoutClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (choiceDeclarationOpenWithoutClose != null) {
      return choiceDeclarationOpenWithoutClose(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentChoiceDeclarationOpenWithoutClose
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentChoiceDeclarationOpenWithoutClose(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentChoiceDeclarationOpenWithoutCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith(
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl value,
          $Res Function(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl)
              then) =
      __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
    implements
        _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<$Res> {
  __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl(
      _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl _value,
      $Res Function(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl
    implements _AnalysedSegmentBooleanDeclarationCloseWithoutOpen {
  _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.booleanDeclarationCloseWithoutOpen(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
      get copyWith =>
          __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
                  _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationCloseWithoutOpen != null) {
      return booleanDeclarationCloseWithoutOpen(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationCloseWithoutOpen != null) {
      return booleanDeclarationCloseWithoutOpen(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentBooleanDeclarationCloseWithoutOpen
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentBooleanDeclarationCloseWithoutOpen(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWith(
          _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl value,
          $Res Function(_$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl)
              then) =
      __$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl>
    implements
        _$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWith<$Res> {
  __$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWithImpl(
      _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl _value,
      $Res Function(_$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl
    implements _AnalysedSegmentChoiceDeclarationCloseWithoutOpen {
  _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.choiceDeclarationCloseWithoutOpen(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl>
      get copyWith =>
          __$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWithImpl<
                  _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return choiceDeclarationCloseWithoutOpen(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return choiceDeclarationCloseWithoutOpen?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (choiceDeclarationCloseWithoutOpen != null) {
      return choiceDeclarationCloseWithoutOpen(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return choiceDeclarationCloseWithoutOpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return choiceDeclarationCloseWithoutOpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (choiceDeclarationCloseWithoutOpen != null) {
      return choiceDeclarationCloseWithoutOpen(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentChoiceDeclarationCloseWithoutOpen
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentChoiceDeclarationCloseWithoutOpen(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentChoiceDeclarationCloseWithoutOpenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith(
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl value,
          $Res Function(
                  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl)
              then) =
      __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
    implements
        _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
            $Res> {
  __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl(
      _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl _value,
      $Res Function(
              _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl
    implements _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter {
  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.hasDelimitterButIsAnVariableWithoutScope(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
      get copyWith =>
          __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
                  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return hasDelimitterButIsAnVariableWithoutScope(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return hasDelimitterButIsAnVariableWithoutScope?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (hasDelimitterButIsAnVariableWithoutScope != null) {
      return hasDelimitterButIsAnVariableWithoutScope(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return hasDelimitterButIsAnVariableWithoutScope(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return hasDelimitterButIsAnVariableWithoutScope?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (hasDelimitterButIsAnVariableWithoutScope != null) {
      return hasDelimitterButIsAnVariableWithoutScope(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith(
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl value,
          $Res Function(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl)
              then) =
      __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
    implements
        _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<$Res> {
  __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl(
      _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl _value,
      $Res Function(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl
    implements _AnalysedSegmentDeclarationOfUncatalogedVariable {
  _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.declarationOfUncatalogedVariable(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
      get copyWith =>
          __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<
                  _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (declarationOfUncatalogedVariable != null) {
      return declarationOfUncatalogedVariable(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (declarationOfUncatalogedVariable != null) {
      return declarationOfUncatalogedVariable(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentDeclarationOfUncatalogedVariable
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentDeclarationOfUncatalogedVariable(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
    $Res> implements $AnalysedSegmentStatusCopyWith<$Res> {
  factory _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith(
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl value,
          $Res Function(
                  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl)
              then) =
      __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentStatusCopyWithImpl<$Res,
        _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
    implements
        _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
            $Res> {
  __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl(
      _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl _value,
      $Res Function(
              _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl)
          _then)
      : super(_value, _then);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(
        _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl
    implements _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext {
  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl(
      {required this.offset, required this.segmentText});

  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegmentStatus.variableExistsButCannotBeUsedInThisContext(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
      get copyWith =>
          __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
                  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) normalText,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? normalText,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext?.call(
        offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? normalText,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (variableExistsButCannotBeUsedInThisContext != null) {
      return variableExistsButCannotBeUsedInThisContext(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) normalText,
    required TResult Function(_AnalysedSegmentValid value) validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationOpenWithoutClose value)
        choiceDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)
        choiceDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        hasDelimitterButIsAnVariableWithoutScope,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? normalText,
    TResult? Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? normalText,
    TResult Function(_AnalysedSegmentValid value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentChoiceDeclarationOpenWithoutClose value)?
        choiceDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentChoiceDeclarationCloseWithoutOpen value)?
        choiceDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        hasDelimitterButIsAnVariableWithoutScope,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (variableExistsButCannotBeUsedInThisContext != null) {
      return variableExistsButCannotBeUsedInThisContext(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext
    implements AnalysedSegmentStatus {
  factory _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl;

  @override
  TextOffset get offset;
  @override
  String get segmentText;

  /// Create a copy of AnalysedSegmentStatus
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
      get copyWith => throw _privateConstructorUsedError;
}
