// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'analysed_segment.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AnalysedSegment {
// ✅
  String get content => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnalysedSegmentCopyWith<AnalysedSegment> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalysedSegmentCopyWith<$Res> {
  factory $AnalysedSegmentCopyWith(
          AnalysedSegment value, $Res Function(AnalysedSegment) then) =
      _$AnalysedSegmentCopyWithImpl<$Res, AnalysedSegment>;
  @useResult
  $Res call({String content});
}

/// @nodoc
class _$AnalysedSegmentCopyWithImpl<$Res, $Val extends AnalysedSegment>
    implements $AnalysedSegmentCopyWith<$Res> {
  _$AnalysedSegmentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_value.copyWith(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnalysedSegmentTextImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentTextImplCopyWith(_$AnalysedSegmentTextImpl value,
          $Res Function(_$AnalysedSegmentTextImpl) then) =
      __$$AnalysedSegmentTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String content});
}

/// @nodoc
class __$$AnalysedSegmentTextImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res, _$AnalysedSegmentTextImpl>
    implements _$$AnalysedSegmentTextImplCopyWith<$Res> {
  __$$AnalysedSegmentTextImplCopyWithImpl(_$AnalysedSegmentTextImpl _value,
      $Res Function(_$AnalysedSegmentTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_$AnalysedSegmentTextImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentTextImpl implements _AnalysedSegmentText {
  _$AnalysedSegmentTextImpl({required this.content});

// ✅
  @override
  final String content;

  @override
  String toString() {
    return 'AnalysedSegment.text(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentTextImpl &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentTextImplCopyWith<_$AnalysedSegmentTextImpl> get copyWith =>
      __$$AnalysedSegmentTextImplCopyWithImpl<_$AnalysedSegmentTextImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text(content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text?.call(content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentText implements AnalysedSegment {
  factory _AnalysedSegmentText({required final String content}) =
      _$AnalysedSegmentTextImpl;

  @override // ✅
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentTextImplCopyWith<_$AnalysedSegmentTextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentDeclarationImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentDeclarationImplCopyWith(
          _$AnalysedSegmentDeclarationImpl value,
          $Res Function(_$AnalysedSegmentDeclarationImpl) then) =
      __$$AnalysedSegmentDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String content});
}

/// @nodoc
class __$$AnalysedSegmentDeclarationImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentDeclarationImpl>
    implements _$$AnalysedSegmentDeclarationImplCopyWith<$Res> {
  __$$AnalysedSegmentDeclarationImplCopyWithImpl(
      _$AnalysedSegmentDeclarationImpl _value,
      $Res Function(_$AnalysedSegmentDeclarationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_$AnalysedSegmentDeclarationImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentDeclarationImpl implements _AnalysedSegmentDeclaration {
  _$AnalysedSegmentDeclarationImpl({required this.content});

// ✅
  @override
  final String content;

  @override
  String toString() {
    return 'AnalysedSegment.validDeclaration(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentDeclarationImpl &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentDeclarationImplCopyWith<_$AnalysedSegmentDeclarationImpl>
      get copyWith => __$$AnalysedSegmentDeclarationImplCopyWithImpl<
          _$AnalysedSegmentDeclarationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration(content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration?.call(content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (validDeclaration != null) {
      return validDeclaration(content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (validDeclaration != null) {
      return validDeclaration(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentDeclaration implements AnalysedSegment {
  factory _AnalysedSegmentDeclaration({required final String content}) =
      _$AnalysedSegmentDeclarationImpl;

  @override // ✅
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentDeclarationImplCopyWith<_$AnalysedSegmentDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith(
          _$AnalysedSegmentInvalidMapDeclarationImpl value,
          $Res Function(_$AnalysedSegmentInvalidMapDeclarationImpl) then) =
      __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String content});
}

/// @nodoc
class __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentInvalidMapDeclarationImpl>
    implements _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<$Res> {
  __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl(
      _$AnalysedSegmentInvalidMapDeclarationImpl _value,
      $Res Function(_$AnalysedSegmentInvalidMapDeclarationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_$AnalysedSegmentInvalidMapDeclarationImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentInvalidMapDeclarationImpl
    implements _AnalysedSegmentInvalidMapDeclaration {
  _$AnalysedSegmentInvalidMapDeclarationImpl({required this.content});

// ✅
  @override
  final String content;

  @override
  String toString() {
    return 'AnalysedSegment.invalidMapDeclaration(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentInvalidMapDeclarationImpl &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<
          _$AnalysedSegmentInvalidMapDeclarationImpl>
      get copyWith => __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<
          _$AnalysedSegmentInvalidMapDeclarationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration(content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration?.call(content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (invalidMapDeclaration != null) {
      return invalidMapDeclaration(content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (invalidMapDeclaration != null) {
      return invalidMapDeclaration(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentInvalidMapDeclaration
    implements AnalysedSegment {
  factory _AnalysedSegmentInvalidMapDeclaration(
          {required final String content}) =
      _$AnalysedSegmentInvalidMapDeclarationImpl;

  @override // ✅
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<
          _$AnalysedSegmentInvalidMapDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith(
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl value,
          $Res Function(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl)
              then) =
      __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String content});
}

/// @nodoc
class __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
    implements
        _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<$Res> {
  __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl(
      _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl _value,
      $Res Function(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl
    implements _AnalysedSegmentModelDeclarationOpenWithoutClose {
  _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl(
      {required this.content});

// ✅
  @override
  final String content;

  @override
  String toString() {
    return 'AnalysedSegment.modelDeclarationOpenWithoutClose(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
      get copyWith =>
          __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<
                  _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose(content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose?.call(content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationOpenWithoutClose != null) {
      return modelDeclarationOpenWithoutClose(content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationOpenWithoutClose != null) {
      return modelDeclarationOpenWithoutClose(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentModelDeclarationOpenWithoutClose
    implements AnalysedSegment {
  factory _AnalysedSegmentModelDeclarationOpenWithoutClose(
          {required final String content}) =
      _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl;

  @override // ✅
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith(
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl value,
          $Res Function(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl)
              then) =
      __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String content});
}

/// @nodoc
class __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
    implements
        _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<$Res> {
  __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl(
      _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl _value,
      $Res Function(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl
    implements _AnalysedSegmentModelDeclarationCloseWithoutOpen {
  _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl(
      {required this.content});

// ✅
  @override
  final String content;

  @override
  String toString() {
    return 'AnalysedSegment.modelDeclarationCloseWithoutOpen(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
      get copyWith =>
          __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<
                  _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen(content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen?.call(content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationCloseWithoutOpen != null) {
      return modelDeclarationCloseWithoutOpen(content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationCloseWithoutOpen != null) {
      return modelDeclarationCloseWithoutOpen(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentModelDeclarationCloseWithoutOpen
    implements AnalysedSegment {
  factory _AnalysedSegmentModelDeclarationCloseWithoutOpen(
          {required final String content}) =
      _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl;

  @override // ✅
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith(
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl value,
          $Res Function(
                  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl)
              then) =
      __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({String content});
}

/// @nodoc
class __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
    implements
        _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
            $Res> {
  __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl(
      _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl _value,
      $Res Function(
              _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl
    implements _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter {
  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl(
      {required this.content});

// ✅
  @override
  final String content;

  @override
  String toString() {
    return 'AnalysedSegment.nonModelVariableWithOpenOrCloseDelimmiter(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
      get copyWith =>
          __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
                  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter(content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter?.call(content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (nonModelVariableWithOpenOrCloseDelimmiter != null) {
      return nonModelVariableWithOpenOrCloseDelimmiter(content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (nonModelVariableWithOpenOrCloseDelimmiter != null) {
      return nonModelVariableWithOpenOrCloseDelimmiter(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter
    implements AnalysedSegment {
  factory _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter(
          {required final String content}) =
      _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl;

  @override // ✅
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith(
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl value,
          $Res Function(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl)
              then) =
      __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String content});
}

/// @nodoc
class __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
    implements
        _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<$Res> {
  __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl(
      _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl _value,
      $Res Function(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl
    implements _AnalysedSegmentDeclarationOfUncatalogedVariable {
  _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl(
      {required this.content});

// ✅
  @override
  final String content;

  @override
  String toString() {
    return 'AnalysedSegment.declarationOfUncatalogedVariable(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
      get copyWith =>
          __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<
                  _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable(content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable?.call(content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (declarationOfUncatalogedVariable != null) {
      return declarationOfUncatalogedVariable(content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (declarationOfUncatalogedVariable != null) {
      return declarationOfUncatalogedVariable(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentDeclarationOfUncatalogedVariable
    implements AnalysedSegment {
  factory _AnalysedSegmentDeclarationOfUncatalogedVariable(
          {required final String content}) =
      _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl;

  @override // ✅
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith(
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl value,
          $Res Function(
                  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl)
              then) =
      __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({String content});
}

/// @nodoc
class __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
    implements
        _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
            $Res> {
  __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl(
      _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl _value,
      $Res Function(
              _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? content = null,
  }) {
    return _then(
        _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl(
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl
    implements _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext {
  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl(
      {required this.content});

// ✅
  @override
  final String content;

  @override
  String toString() {
    return 'AnalysedSegment.variableExistsButCannotBeUsedInThisContext(content: $content)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl &&
            (identical(other.content, content) || other.content == content));
  }

  @override
  int get hashCode => Object.hash(runtimeType, content);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
      get copyWith =>
          __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
                  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String content) text,
    required TResult Function(String content) validDeclaration,
    required TResult Function(String content) invalidMapDeclaration,
    required TResult Function(String content) modelDeclarationOpenWithoutClose,
    required TResult Function(String content) modelDeclarationCloseWithoutOpen,
    required TResult Function(String content)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String content) declarationOfUncatalogedVariable,
    required TResult Function(String content)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext(content);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String content)? text,
    TResult? Function(String content)? validDeclaration,
    TResult? Function(String content)? invalidMapDeclaration,
    TResult? Function(String content)? modelDeclarationOpenWithoutClose,
    TResult? Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String content)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String content)? declarationOfUncatalogedVariable,
    TResult? Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext?.call(content);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String content)? text,
    TResult Function(String content)? validDeclaration,
    TResult Function(String content)? invalidMapDeclaration,
    TResult Function(String content)? modelDeclarationOpenWithoutClose,
    TResult Function(String content)? modelDeclarationCloseWithoutOpen,
    TResult Function(String content)? nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String content)? declarationOfUncatalogedVariable,
    TResult Function(String content)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (variableExistsButCannotBeUsedInThisContext != null) {
      return variableExistsButCannotBeUsedInThisContext(content);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (variableExistsButCannotBeUsedInThisContext != null) {
      return variableExistsButCannotBeUsedInThisContext(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext
    implements AnalysedSegment {
  factory _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext(
          {required final String content}) =
      _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl;

  @override // ✅
  String get content;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
      get copyWith => throw _privateConstructorUsedError;
}
