// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'analysed_segment.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AnalysedSegment {
// ✅
  String get segmentText => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnalysedSegmentCopyWith<AnalysedSegment> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalysedSegmentCopyWith<$Res> {
  factory $AnalysedSegmentCopyWith(
          AnalysedSegment value, $Res Function(AnalysedSegment) then) =
      _$AnalysedSegmentCopyWithImpl<$Res, AnalysedSegment>;
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class _$AnalysedSegmentCopyWithImpl<$Res, $Val extends AnalysedSegment>
    implements $AnalysedSegmentCopyWith<$Res> {
  _$AnalysedSegmentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_value.copyWith(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnalysedSegmentTextImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentTextImplCopyWith(_$AnalysedSegmentTextImpl value,
          $Res Function(_$AnalysedSegmentTextImpl) then) =
      __$$AnalysedSegmentTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentTextImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res, _$AnalysedSegmentTextImpl>
    implements _$$AnalysedSegmentTextImplCopyWith<$Res> {
  __$$AnalysedSegmentTextImplCopyWithImpl(_$AnalysedSegmentTextImpl _value,
      $Res Function(_$AnalysedSegmentTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentTextImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentTextImpl implements _AnalysedSegmentText {
  _$AnalysedSegmentTextImpl({required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.text(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentTextImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentTextImplCopyWith<_$AnalysedSegmentTextImpl> get copyWith =>
      __$$AnalysedSegmentTextImplCopyWithImpl<_$AnalysedSegmentTextImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentText implements AnalysedSegment {
  factory _AnalysedSegmentText({required final String segmentText}) =
      _$AnalysedSegmentTextImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentTextImplCopyWith<_$AnalysedSegmentTextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentDeclarationImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentDeclarationImplCopyWith(
          _$AnalysedSegmentDeclarationImpl value,
          $Res Function(_$AnalysedSegmentDeclarationImpl) then) =
      __$$AnalysedSegmentDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentDeclarationImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentDeclarationImpl>
    implements _$$AnalysedSegmentDeclarationImplCopyWith<$Res> {
  __$$AnalysedSegmentDeclarationImplCopyWithImpl(
      _$AnalysedSegmentDeclarationImpl _value,
      $Res Function(_$AnalysedSegmentDeclarationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentDeclarationImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentDeclarationImpl implements _AnalysedSegmentDeclaration {
  _$AnalysedSegmentDeclarationImpl({required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.validDeclaration(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentDeclarationImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentDeclarationImplCopyWith<_$AnalysedSegmentDeclarationImpl>
      get copyWith => __$$AnalysedSegmentDeclarationImplCopyWithImpl<
          _$AnalysedSegmentDeclarationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (validDeclaration != null) {
      return validDeclaration(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (validDeclaration != null) {
      return validDeclaration(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentDeclaration implements AnalysedSegment {
  factory _AnalysedSegmentDeclaration({required final String segmentText}) =
      _$AnalysedSegmentDeclarationImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentDeclarationImplCopyWith<_$AnalysedSegmentDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith(
          _$AnalysedSegmentInvalidMapDeclarationImpl value,
          $Res Function(_$AnalysedSegmentInvalidMapDeclarationImpl) then) =
      __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentInvalidMapDeclarationImpl>
    implements _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<$Res> {
  __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl(
      _$AnalysedSegmentInvalidMapDeclarationImpl _value,
      $Res Function(_$AnalysedSegmentInvalidMapDeclarationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentInvalidMapDeclarationImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentInvalidMapDeclarationImpl
    implements _AnalysedSegmentInvalidMapDeclaration {
  _$AnalysedSegmentInvalidMapDeclarationImpl({required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.invalidMapDeclaration(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentInvalidMapDeclarationImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<
          _$AnalysedSegmentInvalidMapDeclarationImpl>
      get copyWith => __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<
          _$AnalysedSegmentInvalidMapDeclarationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (invalidMapDeclaration != null) {
      return invalidMapDeclaration(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (invalidMapDeclaration != null) {
      return invalidMapDeclaration(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentInvalidMapDeclaration
    implements AnalysedSegment {
  factory _AnalysedSegmentInvalidMapDeclaration(
          {required final String segmentText}) =
      _$AnalysedSegmentInvalidMapDeclarationImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<
          _$AnalysedSegmentInvalidMapDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith(
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl value,
          $Res Function(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl)
              then) =
      __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
    implements
        _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<$Res> {
  __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl(
      _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl _value,
      $Res Function(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl
    implements _AnalysedSegmentModelDeclarationOpenWithoutClose {
  _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl(
      {required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.modelDeclarationOpenWithoutClose(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
      get copyWith =>
          __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<
                  _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationOpenWithoutClose != null) {
      return modelDeclarationOpenWithoutClose(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationOpenWithoutClose != null) {
      return modelDeclarationOpenWithoutClose(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentModelDeclarationOpenWithoutClose
    implements AnalysedSegment {
  factory _AnalysedSegmentModelDeclarationOpenWithoutClose(
          {required final String segmentText}) =
      _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith(
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl value,
          $Res Function(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl)
              then) =
      __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
    implements
        _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<$Res> {
  __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl(
      _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl _value,
      $Res Function(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl
    implements _AnalysedSegmentModelDeclarationCloseWithoutOpen {
  _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl(
      {required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.modelDeclarationCloseWithoutOpen(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
      get copyWith =>
          __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<
                  _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationCloseWithoutOpen != null) {
      return modelDeclarationCloseWithoutOpen(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationCloseWithoutOpen != null) {
      return modelDeclarationCloseWithoutOpen(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentModelDeclarationCloseWithoutOpen
    implements AnalysedSegment {
  factory _AnalysedSegmentModelDeclarationCloseWithoutOpen(
          {required final String segmentText}) =
      _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith(
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl value,
          $Res Function(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl)
              then) =
      __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
    implements
        _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<$Res> {
  __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl(
      _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl _value,
      $Res Function(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl
    implements _AnalysedSegmentBooleanDeclarationOpenWithoutClose {
  _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl(
      {required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.booleanDeclarationOpenWithoutClose(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
      get copyWith =>
          __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
                  _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationOpenWithoutClose != null) {
      return booleanDeclarationOpenWithoutClose(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationOpenWithoutClose != null) {
      return booleanDeclarationOpenWithoutClose(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentBooleanDeclarationOpenWithoutClose
    implements AnalysedSegment {
  factory _AnalysedSegmentBooleanDeclarationOpenWithoutClose(
          {required final String segmentText}) =
      _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith(
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl value,
          $Res Function(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl)
              then) =
      __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
    implements
        _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<$Res> {
  __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl(
      _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl _value,
      $Res Function(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl
    implements _AnalysedSegmentBooleanDeclarationCloseWithoutOpen {
  _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl(
      {required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.booleanDeclarationCloseWithoutOpen(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
      get copyWith =>
          __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
                  _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationCloseWithoutOpen != null) {
      return booleanDeclarationCloseWithoutOpen(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationCloseWithoutOpen != null) {
      return booleanDeclarationCloseWithoutOpen(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentBooleanDeclarationCloseWithoutOpen
    implements AnalysedSegment {
  factory _AnalysedSegmentBooleanDeclarationCloseWithoutOpen(
          {required final String segmentText}) =
      _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith(
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl value,
          $Res Function(
                  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl)
              then) =
      __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
    implements
        _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
            $Res> {
  __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl(
      _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl _value,
      $Res Function(
              _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl
    implements _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter {
  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl(
      {required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.nonModelVariableWithOpenOrCloseDelimmiter(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
      get copyWith =>
          __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
                  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (nonModelVariableWithOpenOrCloseDelimmiter != null) {
      return nonModelVariableWithOpenOrCloseDelimmiter(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (nonModelVariableWithOpenOrCloseDelimmiter != null) {
      return nonModelVariableWithOpenOrCloseDelimmiter(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter
    implements AnalysedSegment {
  factory _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter(
          {required final String segmentText}) =
      _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith(
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl value,
          $Res Function(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl)
              then) =
      __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
    implements
        _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<$Res> {
  __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl(
      _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl _value,
      $Res Function(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl
    implements _AnalysedSegmentDeclarationOfUncatalogedVariable {
  _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl(
      {required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.declarationOfUncatalogedVariable(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
      get copyWith =>
          __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<
                  _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (declarationOfUncatalogedVariable != null) {
      return declarationOfUncatalogedVariable(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (declarationOfUncatalogedVariable != null) {
      return declarationOfUncatalogedVariable(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentDeclarationOfUncatalogedVariable
    implements AnalysedSegment {
  factory _AnalysedSegmentDeclarationOfUncatalogedVariable(
          {required final String segmentText}) =
      _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith(
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl value,
          $Res Function(
                  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl)
              then) =
      __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
    implements
        _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
            $Res> {
  __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl(
      _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl _value,
      $Res Function(
              _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? segmentText = null,
  }) {
    return _then(
        _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl(
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl
    implements _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext {
  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl(
      {required this.segmentText});

// ✅
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.variableExistsButCannotBeUsedInThisContext(segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
      get copyWith =>
          __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
                  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String segmentText) text,
    required TResult Function(String segmentText) validDeclaration,
    required TResult Function(String segmentText) invalidMapDeclaration,
    required TResult Function(String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String segmentText)? text,
    TResult? Function(String segmentText)? validDeclaration,
    TResult? Function(String segmentText)? invalidMapDeclaration,
    TResult? Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult? Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult? Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult? Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext?.call(segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String segmentText)? text,
    TResult Function(String segmentText)? validDeclaration,
    TResult Function(String segmentText)? invalidMapDeclaration,
    TResult Function(String segmentText)? modelDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? modelDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)? booleanDeclarationOpenWithoutClose,
    TResult Function(String segmentText)? booleanDeclarationCloseWithoutOpen,
    TResult Function(String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(String segmentText)? declarationOfUncatalogedVariable,
    TResult Function(String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (variableExistsButCannotBeUsedInThisContext != null) {
      return variableExistsButCannotBeUsedInThisContext(segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (variableExistsButCannotBeUsedInThisContext != null) {
      return variableExistsButCannotBeUsedInThisContext(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext
    implements AnalysedSegment {
  factory _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext(
          {required final String segmentText}) =
      _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl;

  @override // ✅
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
      get copyWith => throw _privateConstructorUsedError;
}
