// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'analysed_segment.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AnalysedSegment {
// ✅
  TextOffset get offset => throw _privateConstructorUsedError;
  String get segmentText => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AnalysedSegmentCopyWith<AnalysedSegment> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalysedSegmentCopyWith<$Res> {
  factory $AnalysedSegmentCopyWith(
          AnalysedSegment value, $Res Function(AnalysedSegment) then) =
      _$AnalysedSegmentCopyWithImpl<$Res, AnalysedSegment>;
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class _$AnalysedSegmentCopyWithImpl<$Res, $Val extends AnalysedSegment>
    implements $AnalysedSegmentCopyWith<$Res> {
  _$AnalysedSegmentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_value.copyWith(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AnalysedSegmentTextImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentTextImplCopyWith(_$AnalysedSegmentTextImpl value,
          $Res Function(_$AnalysedSegmentTextImpl) then) =
      __$$AnalysedSegmentTextImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentTextImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res, _$AnalysedSegmentTextImpl>
    implements _$$AnalysedSegmentTextImplCopyWith<$Res> {
  __$$AnalysedSegmentTextImplCopyWithImpl(_$AnalysedSegmentTextImpl _value,
      $Res Function(_$AnalysedSegmentTextImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentTextImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentTextImpl implements _AnalysedSegmentText {
  _$AnalysedSegmentTextImpl({required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.text(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentTextImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentTextImplCopyWith<_$AnalysedSegmentTextImpl> get copyWith =>
      __$$AnalysedSegmentTextImplCopyWithImpl<_$AnalysedSegmentTextImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentText implements AnalysedSegment {
  factory _AnalysedSegmentText(
      {required final TextOffset offset,
      required final String segmentText}) = _$AnalysedSegmentTextImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentTextImplCopyWith<_$AnalysedSegmentTextImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentDeclarationImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentDeclarationImplCopyWith(
          _$AnalysedSegmentDeclarationImpl value,
          $Res Function(_$AnalysedSegmentDeclarationImpl) then) =
      __$$AnalysedSegmentDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentDeclarationImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentDeclarationImpl>
    implements _$$AnalysedSegmentDeclarationImplCopyWith<$Res> {
  __$$AnalysedSegmentDeclarationImplCopyWithImpl(
      _$AnalysedSegmentDeclarationImpl _value,
      $Res Function(_$AnalysedSegmentDeclarationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentDeclarationImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentDeclarationImpl implements _AnalysedSegmentDeclaration {
  _$AnalysedSegmentDeclarationImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.validDeclaration(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentDeclarationImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentDeclarationImplCopyWith<_$AnalysedSegmentDeclarationImpl>
      get copyWith => __$$AnalysedSegmentDeclarationImplCopyWithImpl<
          _$AnalysedSegmentDeclarationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (validDeclaration != null) {
      return validDeclaration(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return validDeclaration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (validDeclaration != null) {
      return validDeclaration(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentDeclaration implements AnalysedSegment {
  factory _AnalysedSegmentDeclaration(
      {required final TextOffset offset,
      required final String segmentText}) = _$AnalysedSegmentDeclarationImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentDeclarationImplCopyWith<_$AnalysedSegmentDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<$Res>
    implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith(
          _$AnalysedSegmentInvalidMapDeclarationImpl value,
          $Res Function(_$AnalysedSegmentInvalidMapDeclarationImpl) then) =
      __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentInvalidMapDeclarationImpl>
    implements _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<$Res> {
  __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl(
      _$AnalysedSegmentInvalidMapDeclarationImpl _value,
      $Res Function(_$AnalysedSegmentInvalidMapDeclarationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentInvalidMapDeclarationImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentInvalidMapDeclarationImpl
    implements _AnalysedSegmentInvalidMapDeclaration {
  _$AnalysedSegmentInvalidMapDeclarationImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.invalidMapDeclaration(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentInvalidMapDeclarationImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<
          _$AnalysedSegmentInvalidMapDeclarationImpl>
      get copyWith => __$$AnalysedSegmentInvalidMapDeclarationImplCopyWithImpl<
          _$AnalysedSegmentInvalidMapDeclarationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (invalidMapDeclaration != null) {
      return invalidMapDeclaration(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return invalidMapDeclaration?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (invalidMapDeclaration != null) {
      return invalidMapDeclaration(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentInvalidMapDeclaration
    implements AnalysedSegment {
  factory _AnalysedSegmentInvalidMapDeclaration(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentInvalidMapDeclarationImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentInvalidMapDeclarationImplCopyWith<
          _$AnalysedSegmentInvalidMapDeclarationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith(
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl value,
          $Res Function(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl)
              then) =
      __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
    implements
        _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<$Res> {
  __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl(
      _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl _value,
      $Res Function(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl
    implements _AnalysedSegmentModelDeclarationOpenWithoutClose {
  _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.modelDeclarationOpenWithoutClose(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
      get copyWith =>
          __$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWithImpl<
                  _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationOpenWithoutClose != null) {
      return modelDeclarationOpenWithoutClose(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationOpenWithoutClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationOpenWithoutClose != null) {
      return modelDeclarationOpenWithoutClose(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentModelDeclarationOpenWithoutClose
    implements AnalysedSegment {
  factory _AnalysedSegmentModelDeclarationOpenWithoutClose(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentModelDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentModelDeclarationOpenWithoutCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith(
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl value,
          $Res Function(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl)
              then) =
      __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
    implements
        _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<$Res> {
  __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl(
      _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl _value,
      $Res Function(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl
    implements _AnalysedSegmentModelDeclarationCloseWithoutOpen {
  _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.modelDeclarationCloseWithoutOpen(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
      get copyWith =>
          __$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWithImpl<
                  _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationCloseWithoutOpen != null) {
      return modelDeclarationCloseWithoutOpen(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return modelDeclarationCloseWithoutOpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (modelDeclarationCloseWithoutOpen != null) {
      return modelDeclarationCloseWithoutOpen(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentModelDeclarationCloseWithoutOpen
    implements AnalysedSegment {
  factory _AnalysedSegmentModelDeclarationCloseWithoutOpen(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentModelDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentModelDeclarationCloseWithoutOpenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith(
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl value,
          $Res Function(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl)
              then) =
      __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
    implements
        _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<$Res> {
  __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl(
      _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl _value,
      $Res Function(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl
    implements _AnalysedSegmentBooleanDeclarationOpenWithoutClose {
  _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.booleanDeclarationOpenWithoutClose(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
      get copyWith =>
          __$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWithImpl<
                  _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationOpenWithoutClose != null) {
      return booleanDeclarationOpenWithoutClose(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationOpenWithoutClose?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationOpenWithoutClose != null) {
      return booleanDeclarationOpenWithoutClose(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentBooleanDeclarationOpenWithoutClose
    implements AnalysedSegment {
  factory _AnalysedSegmentBooleanDeclarationOpenWithoutClose(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationOpenWithoutCloseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith(
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl value,
          $Res Function(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl)
              then) =
      __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
    implements
        _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<$Res> {
  __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl(
      _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl _value,
      $Res Function(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl
    implements _AnalysedSegmentBooleanDeclarationCloseWithoutOpen {
  _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.booleanDeclarationCloseWithoutOpen(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
      get copyWith =>
          __$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWithImpl<
                  _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationCloseWithoutOpen != null) {
      return booleanDeclarationCloseWithoutOpen(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return booleanDeclarationCloseWithoutOpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (booleanDeclarationCloseWithoutOpen != null) {
      return booleanDeclarationCloseWithoutOpen(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentBooleanDeclarationCloseWithoutOpen
    implements AnalysedSegment {
  factory _AnalysedSegmentBooleanDeclarationCloseWithoutOpen(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImplCopyWith<
          _$AnalysedSegmentBooleanDeclarationCloseWithoutOpenImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith(
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl value,
          $Res Function(
                  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl)
              then) =
      __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
    implements
        _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
            $Res> {
  __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl(
      _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl _value,
      $Res Function(
              _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl
    implements _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter {
  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.nonModelVariableWithOpenOrCloseDelimmiter(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
      get copyWith =>
          __$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWithImpl<
                  _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (nonModelVariableWithOpenOrCloseDelimmiter != null) {
      return nonModelVariableWithOpenOrCloseDelimmiter(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return nonModelVariableWithOpenOrCloseDelimmiter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (nonModelVariableWithOpenOrCloseDelimmiter != null) {
      return nonModelVariableWithOpenOrCloseDelimmiter(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter
    implements AnalysedSegment {
  factory _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImplCopyWith<
          _$AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiterImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith(
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl value,
          $Res Function(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl)
              then) =
      __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<$Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
    implements
        _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<$Res> {
  __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl(
      _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl _value,
      $Res Function(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(_$AnalysedSegmentDeclarationOfUncatalogedVariableImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl
    implements _AnalysedSegmentDeclarationOfUncatalogedVariable {
  _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.declarationOfUncatalogedVariable(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
      get copyWith =>
          __$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWithImpl<
                  _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable?.call(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (declarationOfUncatalogedVariable != null) {
      return declarationOfUncatalogedVariable(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return declarationOfUncatalogedVariable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (declarationOfUncatalogedVariable != null) {
      return declarationOfUncatalogedVariable(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentDeclarationOfUncatalogedVariable
    implements AnalysedSegment {
  factory _AnalysedSegmentDeclarationOfUncatalogedVariable(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentDeclarationOfUncatalogedVariableImplCopyWith<
          _$AnalysedSegmentDeclarationOfUncatalogedVariableImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
    $Res> implements $AnalysedSegmentCopyWith<$Res> {
  factory _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith(
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl value,
          $Res Function(
                  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl)
              then) =
      __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
          $Res>;
  @override
  @useResult
  $Res call({TextOffset offset, String segmentText});
}

/// @nodoc
class __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
        $Res>
    extends _$AnalysedSegmentCopyWithImpl<$Res,
        _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
    implements
        _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
            $Res> {
  __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl(
      _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl _value,
      $Res Function(
              _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offset = null,
    Object? segmentText = null,
  }) {
    return _then(
        _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl(
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as TextOffset,
      segmentText: null == segmentText
          ? _value.segmentText
          : segmentText // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl
    implements _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext {
  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl(
      {required this.offset, required this.segmentText});

// ✅
  @override
  final TextOffset offset;
  @override
  final String segmentText;

  @override
  String toString() {
    return 'AnalysedSegment.variableExistsButCannotBeUsedInThisContext(offset: $offset, segmentText: $segmentText)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other
                is _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.segmentText, segmentText) ||
                other.segmentText == segmentText));
  }

  @override
  int get hashCode => Object.hash(runtimeType, offset, segmentText);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
      get copyWith =>
          __$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWithImpl<
                  _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(TextOffset offset, String segmentText) text,
    required TResult Function(TextOffset offset, String segmentText)
        validDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        invalidMapDeclaration,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(TextOffset offset, String segmentText)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(TextOffset offset, String segmentText)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(TextOffset offset, String segmentText)
        declarationOfUncatalogedVariable,
    required TResult Function(TextOffset offset, String segmentText)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext(offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(TextOffset offset, String segmentText)? text,
    TResult? Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult? Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext?.call(
        offset, segmentText);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(TextOffset offset, String segmentText)? text,
    TResult Function(TextOffset offset, String segmentText)? validDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        invalidMapDeclaration,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(TextOffset offset, String segmentText)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(TextOffset offset, String segmentText)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(TextOffset offset, String segmentText)?
        declarationOfUncatalogedVariable,
    TResult Function(TextOffset offset, String segmentText)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (variableExistsButCannotBeUsedInThisContext != null) {
      return variableExistsButCannotBeUsedInThisContext(offset, segmentText);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnalysedSegmentText value) text,
    required TResult Function(_AnalysedSegmentDeclaration value)
        validDeclaration,
    required TResult Function(_AnalysedSegmentInvalidMapDeclaration value)
        invalidMapDeclaration,
    required TResult Function(
            _AnalysedSegmentModelDeclarationOpenWithoutClose value)
        modelDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentModelDeclarationCloseWithoutOpen value)
        modelDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationOpenWithoutClose value)
        booleanDeclarationOpenWithoutClose,
    required TResult Function(
            _AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)
        booleanDeclarationCloseWithoutOpen,
    required TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)
        nonModelVariableWithOpenOrCloseDelimmiter,
    required TResult Function(
            _AnalysedSegmentDeclarationOfUncatalogedVariable value)
        declarationOfUncatalogedVariable,
    required TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AnalysedSegmentText value)? text,
    TResult? Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult? Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult? Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult? Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult? Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult? Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult? Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult? Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
  }) {
    return variableExistsButCannotBeUsedInThisContext?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnalysedSegmentText value)? text,
    TResult Function(_AnalysedSegmentDeclaration value)? validDeclaration,
    TResult Function(_AnalysedSegmentInvalidMapDeclaration value)?
        invalidMapDeclaration,
    TResult Function(_AnalysedSegmentModelDeclarationOpenWithoutClose value)?
        modelDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentModelDeclarationCloseWithoutOpen value)?
        modelDeclarationCloseWithoutOpen,
    TResult Function(_AnalysedSegmentBooleanDeclarationOpenWithoutClose value)?
        booleanDeclarationOpenWithoutClose,
    TResult Function(_AnalysedSegmentBooleanDeclarationCloseWithoutOpen value)?
        booleanDeclarationCloseWithoutOpen,
    TResult Function(
            _AnalysedSegmentNonModelVariableWithOpenOrCloseDelimmiter value)?
        nonModelVariableWithOpenOrCloseDelimmiter,
    TResult Function(_AnalysedSegmentDeclarationOfUncatalogedVariable value)?
        declarationOfUncatalogedVariable,
    TResult Function(
            _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext value)?
        variableExistsButCannotBeUsedInThisContext,
    required TResult orElse(),
  }) {
    if (variableExistsButCannotBeUsedInThisContext != null) {
      return variableExistsButCannotBeUsedInThisContext(this);
    }
    return orElse();
  }
}

abstract class _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext
    implements AnalysedSegment {
  factory _AnalysedSegmentVariableExistsButCannotBeUsedInThisContext(
          {required final TextOffset offset,
          required final String segmentText}) =
      _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl;

  @override // ✅
  TextOffset get offset;
  @override
  String get segmentText;
  @override
  @JsonKey(ignore: true)
  _$$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImplCopyWith<
          _$AnalysedSegmentVariableExistsButCannotBeUsedInThisContextImpl>
      get copyWith => throw _privateConstructorUsedError;
}
